import numpy as np
from scipy import interpolate
import scipy.linalg as sp

def identify_hotspots_and_suburbs(population_density):
    """
    Divides a region into "hotspots" (high population density areas) and
    "suburbs" (lower population density areas) based on the provided
    population density data.

    This function uses a spline interpolation method to find a threshold
    in the population density distribution.  Areas with population
    densities above this threshold are classified as hotspots, and those
    below as suburbs.

    Args:
        population_density (list or numpy.ndarray): A 1D array representing
            the population density of different areas.  The order of
            elements in this array is important, as it corresponds to
            the spatial arrangement of the areas.

    Returns:
        tuple: A tuple containing two lists:
            - hotspot_indices (list): A list of indices corresponding to the
              areas identified as hotspots.
            - suburb_indices (list): A list of indices corresponding to the
              areas identified as suburbs.

    Raises:
        TypeError: If the input `population_density` is not a list or a
            numpy array.
        ValueError: If the input `population_density` is empty.

    Example:
        >>> population_density = [100, 200, 50, 300, 150, 25]
        >>> hotspots, suburbs = identify_hotspots_and_suburbs(population_density)
        >>> print(f"Hotspot indices: {hotspots}")
        >>> print(f"Suburb indices: {suburbs}")
    """
    if not isinstance(population_density, (list, np.ndarray)):
        raise TypeError("population_density must be a list or a numpy array")
    if not population_density:
        raise ValueError("population_density cannot be empty")

    V = np.array(population_density)  # Ensure V is a numpy array for easier operations
    N = len(V)
    sorted_population_density = np.sort(V)  # Sort the population densities
    sorted_indices = np.argsort(V)  # Get the original indices of the sorted values

    # Calculate the cumulative sum of sorted population densities
    cumulative_population_density = np.cumsum(sorted_population_density)

    # Create an array of x-values for interpolation
    x = np.linspace(0, N - 1, N)

    # Perform spline interpolation on the cumulative population densities
    spline_function = interpolate.splrep(x, cumulative_population_density)

    # Evaluate the spline at the maximum x-value
    x0 = max(x)
    y0 = interpolate.splev(x0, spline_function)

    # Calculate the derivative of the spline at x0
    dydx = interpolate.splev(x0, spline_function, der=1)

    # Define the tangent line function
    tangent_line = lambda x: dydx * x + (y0 - dydx * x0)
    y1 = tangent_line(x)

    # Find the x-intercept of the tangent line (where it crosses y=0)
    x1 = next((x[i] for i in range(len(y1)) if y1[i] > 0), None) # Returns the first x where y1 > 0, or None if never true.
    if x1 is None:
        x1 = 0 # if the tangent line never goes above 0, set x1 to 0.

    # Identify hotspots and suburbs based on the x-intercept
    hotspot_indices = list(sorted_indices[int(x1):])
    suburb_indices = list(sorted_indices[:int(x1)])

    return hotspot_indices, suburb_indices



def calculate_vbd_vulnerability(mobility_matrix, mosquito_population, human_population):
    """
    Calculates the epidemic vulnerability for a vector-borne disease (VBD)
    based on human mobility, mosquito population, and human population.

    This function computes a matrix that represents the potential for disease
    transmission between different areas, considering the movement of people
    and the distribution of mosquitoes.  The leading eigenvalue of this
    matrix is used as a measure of epidemic vulnerability.

    Args:
        mobility_matrix (numpy.ndarray): A 2D numpy array representing the
            mobility of humans between areas.  R[j][i] represents the
            proportion of people from area j that move to area i.
        mosquito_population (list or numpy.ndarray): A 1D array representing
            the mosquito population in each area.
        human_population (list or numpy.ndarray): A 1D array representing
            the human population in each area.

    Returns:
        float: The epidemic vulnerability, calculated as the square root of
            the leading eigenvalue of the transmission matrix.

    Raises:
        TypeError: If any of the input arguments have an incorrect type.
        ValueError: If the dimensions of the input arrays are incompatible.
    """
    # Input validation
    if not isinstance(mobility_matrix, np.ndarray):
        raise TypeError("mobility_matrix must be a numpy array")
    if not isinstance(mosquito_population, (list, np.ndarray)):
        raise TypeError("mosquito_population must be a list or numpy array")
    if not isinstance(human_population, (list, np.ndarray)):
        raise TypeError("human_population must be a list or numpy array")

    mosquito_population = np.array(mosquito_population)
    human_population = np.array(human_population)
    N = len(human_population)

    if mobility_matrix.shape != (N, N):
        raise ValueError("mobility_matrix must be a square matrix with dimensions NxN")
    if len(mosquito_population) != N:
        raise ValueError("mosquito_population must have the same length as human_population")
    if len(human_population) != N:
        raise ValueError("human_population must have the same length as mosquito_population")

    N_eff = []
    for i in range(N):
        Eff = [mobility_matrix[j][i] * human_population[j] for j in range(N)]
        N_eff.append(sum(Eff))

    M0 = np.zeros((N, N))
    M1 = np.zeros((N, N))

    for i in range(N):
        for j in range(N):
            if N_eff[j] > 0:
                M0[i][j] = mobility_matrix[i][j] * mosquito_population[j] / N_eff[j]
            if N_eff[i] > 0:
                M1[i][j] = mobility_matrix[j][i] * human_population[j] / N_eff[i]

    M2 = np.dot(M0, M1)
    eigenvalues, _ = sp.linalg.eig(M2)  # Use scipy.linalg.eig for non-symmetric matrices
    max_eigenvalue = np.max(np.real(eigenvalues))
    vulnerability = np.sqrt(max_eigenvalue)
    return vulnerability



def calculate_abd_vulnerability(mobility_matrix, human_population, area):
    """
    Calculates the epidemic vulnerability for an airborne disease (ABD)
    based on human mobility, human population, and area.

    This function computes a matrix that represents the potential for disease
    transmission between different areas, considering the movement of people
    and the size of each area. The leading eigenvalue of this
    matrix is used as a measure of epidemic vulnerability.

    Args:
        mobility_matrix (numpy.ndarray): A 2D numpy array representing the
            mobility of humans between areas. R[i][j] represents the
            proportion of people from area j that move to area i.
        human_population (list or numpy.ndarray): A 1D array representing
            the human population in each area.
        area (list or numpy.ndarray): A 1D array representing the area of each region.

    Returns:
        float: The epidemic vulnerability, calculated as the leading
            eigenvalue of the transmission matrix.

     Raises:
        TypeError: If any of the input arguments have an incorrect type.
        ValueError: If the dimensions of the input arrays are incompatible.
    """
    # Input validation
    if not isinstance(mobility_matrix, np.ndarray):
        raise TypeError("mobility_matrix must be a numpy array.")
    if not isinstance(human_population, (list, np.ndarray)):
        raise TypeError("human_population must be a list or numpy array.")
    if not isinstance(area, (list, np.ndarray)):
        raise TypeError("area must be a list or numpy array.")

    human_population = np.array(human_population)
    area = np.array(area)
    N = len(human_population)

    if mobility_matrix.shape != (N, N):
        raise ValueError("mobility_matrix must be a square matrix with dimensions NxN")
    if len(human_population) != N:
        raise ValueError("human_population must have the same length as area and match the dimensions of mobility_matrix")
    if len(area) != N:
        raise ValueError("area must have the same length as human_population and match the dimensions of mobility_matrix")
    M = np.zeros((N, N))
    for i in range(N):
        for j in range(N):
            A = [mobility_matrix[i][l] * mobility_matrix[j][l] / area[l] for l in range(N)]
            M[i][j] = human_population[j] * np.sum(A)
    eigenvalues, _ = np.linalg.eig(M)
    max_eigenvalue = np.max(np.real(eigenvalues))
    vulnerability = max_eigenvalue
    return vulnerability
